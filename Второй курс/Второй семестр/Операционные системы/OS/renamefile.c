#include<stdlib.h>
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<unistd.h>
#include"rf.h"

#define BS 1//снова читаем по одному байту
char bufl[BS];//буффер для читаемых данных

void renamefile(char *path, char *nname)//функция получает путь и новое имя файла из главной программы (main.c)
{
    int i = 0, ffd, std;//счетчик кол-ва байтов, для первого и второга файлов
    ssize_t count;//для представления размера выделенного блока памяти
    ffd = open(path, O_RDONLY);//открываем файл с правами только для чтения
    if (ffd==-1)//если открыть не удалось (файл не сущ или это папка и тд) то выведем ошибку
    {
      errl();
    }
    std = open(nname, O_WRONLY|O_CREAT|O_EXCL, 0644);//открываем файл с именем nname и правами доступа в следующем порядке Только чтение, Создать файл, если не существует, Выдать ошибку при использовании O_CREAT, если файл существует, про цифры см приложение.txt
    if (std==-1)//если открыть не удалось (файл не сущ или это папка и тд) то выведем ошибку
    {
      errl();
    }
    while(count=read(ffd,bufl,BS)>0)//до тех пор пока не дойдём до конца файла
    {
        write(std, bufl, count);//записывает до count байтов из буфера buf в std
        i++;//опять плюсы в чистом Си
    }
    if(count==-1)errl();//если встретился маркер конца файла или если до того, как было считано count байт, произошла ошибка, то вывести ошебку
    printf("Copy succesfull\n");//принтуем что всё гут
    printf("Bytes copyed: %d\n", i);//сколько байт скопировали тоже принтуем
    //закрываем первый файл
    close(ffd);
    //удаляем его (точнее его мягкую ссылку, ну вдруг доебётся)
    unlink(path);
    //выводим, что всё гут удолилос
    printf("Source file sucsefully deleted\n");
    //закрываем Азамат файл
    close(std);
}
